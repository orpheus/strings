package service

import (
	"fmt"
	"github.com/google/uuid"
	"github.com/orpheus/strings/pkg/core"
)

func NewThreadService(threadRepository ThreadRepository) *ThreadService {
	return &ThreadService{
		ThreadRepository: threadRepository,
	}
}

type ThreadService struct {
	ThreadRepository ThreadRepository
}

type ThreadRepository interface {
	FindByThreadId(threadId uuid.UUID) (*core.Thread, error)
	CreateThread(name string, id, threadId uuid.UUID) (*core.Thread, error)
	UpdateThread(clientThread *core.Thread) (*core.Thread, error)
	FindAll() ([]*core.Thread, error)
}

func (t *ThreadService) PostThread(thread *core.Thread) (*core.Thread, error) {
	if thread.ThreadId == (uuid.UUID{}) {
		return t.createNewThread(thread)
	}

	existingThread, err := t.ThreadRepository.FindByThreadId(thread.ThreadId)
	if err != nil {
		return nil, fmt.Errorf("thread repository failed to find thread by ThreadId: %s", err)
	}

	if existingThread == nil {
		return t.createNewThread(thread)
	} else {
		return t.updateThreadIfNeeded(thread, existingThread)
	}
}

// note: thread name+version combination should be unique
func (t *ThreadService) createNewThread(thread *core.Thread) (*core.Thread, error) {
	if thread.Name == "" {
		return nil, fmt.Errorf("failed to create new thread, missing `name`")
	}

	if thread.ThreadId == (uuid.UUID{}) {
		thread.ThreadId = uuid.New()
	}

	// Versioned Thread ID always generated by server to reduce api complexity and confusion
	versionedThreadId := uuid.New()

	newThread, err := t.ThreadRepository.CreateThread(thread.Name, versionedThreadId, thread.ThreadId)
	if err != nil {
		return nil, fmt.Errorf("failed to create new thread: %s\n", err)
	}

	return newThread, nil
}

func (t *ThreadService) updateThreadIfNeeded(clientThread *core.Thread, serverThread *core.Thread) (*core.Thread, error) {
	if clientThread.Diff(serverThread) {
		return t.ThreadRepository.UpdateThread(clientThread)
	}

	return serverThread, nil
}

func (t *ThreadService) GetThreads() ([]*core.Thread, error) {
	return t.ThreadRepository.FindAll()
}

func (t *ThreadService) GetThreadIds() ([]uuid.UUID, error) {
	//TODO implement me
	panic("implement me")
}

func (t *ThreadService) ArchiveThread(id uuid.UUID) (*core.Thread, error) {
	//TODO implement me
	panic("implement me")
}

func (t *ThreadService) RestoreThread(id uuid.UUID) (*core.Thread, error) {
	//TODO implement me
	panic("implement me")
}

func (t *ThreadService) ActivateThread(id uuid.UUID) (*core.Thread, error) {
	//TODO implement me
	panic("implement me")
}

func (t *ThreadService) DeactivateThread(id uuid.UUID) (*core.Thread, error) {
	//TODO implement me
	panic("implement me")
}

func (t *ThreadService) DeleteThread(id uuid.UUID) (*core.Thread, error) {
	//TODO implement me
	panic("implement me")
}
